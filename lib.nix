{ pkgs }:
let

    lib = pkgs.lib;

    # Default message to be added to the top of each script
    script-msg = ''
        # This script was generated by Nix.
        # To make changes edit the `tasks.nix` file.

    '';

    # Name of the help task
    help-task-name = "task-help";

    _taskScriptString = task: level: ''
        echo "${ lib.strings.replicate level "--" }->> Running '${task.name}'"
        # Dependencies for ${task.name}
        ${builtins.concatStringsSep "\n" (map (j: _taskScriptString j (level+1)) task.depends)}
        # Run ${task.name} task
        ${task.script}
    '';

    _tabIndent = s: (if s == "" then "" else "\t") + (builtins.concatStringsSep "\n\t" (
        builtins.filter (e: builtins.typeOf e != "list") (builtins.split "\n" s)
    ));

    _writeScript = name: script: pkgs.stdenv.mkDerivation {
        name = name;
        phases = [ "installPhase" ];
        installPhase = ''
            touch $out
            echo -e "#!/bin/sh\n" > $out
            cat ${pkgs.writeText "script" script} >> $out
            chmod +x "$out"
        '';
    };

    _writeScriptBin = name: script: pkgs.stdenv.mkDerivation {
        name = name;
        phases = [ "installPhase" ];
        installPhase = ''
            mkdir -p "$out/bin"
            echo -e "#!/bin/sh\n" > "$out/bin/${name}"
            cat ${pkgs.writeText "script" script} >> "$out/bin/${name}"
            chmod +x "$out/bin/${name}"
        '';
    };

    _mkScript = write_script: task: write_script task.name (script-msg + (_taskScriptString task 0));

    # TODO: Check that tasks are available in shell
    _mkHelpScript = write_script: tasks:
    let
        task_names = if builtins.typeOf tasks == "list" then tasks else builtins.attrValues tasks;
    in
    write_script "${help-task-name}" ''
        echo "Available Tasks:"
        ${ builtins.concatStringsSep "\n" (map (j:  "echo -e '\t${j.name}'") task_names) }

        # Only print if `${help-task-name}` is in current PATH
        echo -e "\nUse '${help-task-name}' command to show this list."
    '';

in
rec {

    #: Create a task
    mkTask = name: { script ? "", depends ? [], }: {
        name = name;
        script = script;
        depends = depends;
    };

    #: Create a sequence of tasks
    mkSeq = name: seq: mkTask name { depends = seq; };

    #: Generate a script (package) that executes a task
    mkScriptBin = _mkScript _writeScriptBin;

    #: Generate a script that executes a task
    mkScript = _mkScript _writeScript;

    #: Generate a help script that lists all tasks
    mkHelpScript = _mkHelpScript _writeScript;

    #: Generate a help script (package) that lists all tasks
    mkHelpScriptBin = _mkHelpScript _writeScriptBin;

    #: Generate a list of scripts for each task
    mkScripts = tasks: (lib.attrsets.mapAttrsToList (_: j: mkScriptBin j) tasks) ++ [(mkHelpScriptBin tasks)];

    #: Generate a Makefile for tasks
    mkMakefile = tasks: let
        task_list = if builtins.typeOf tasks == "list" then tasks else builtins.attrValues tasks;
    in
    pkgs.writeText "Makefile" (''
        # This Makefile was generated by Nix.
        # To make changes edit the `tasks.nix` file.

        main: ${help-task-name}

        ${help-task-name}:
        ${ _tabIndent /*bash*/ ''
            @echo "usage: make <task>"
            @echo ""
            @echo "Available Tasks:"
            ${ (builtins.concatStringsSep "\n" (map (j:  "@echo -e '\t${j.name}'") task_list)) }
            @echo -e "\nUse 'make ${help-task-name}' command to show this list."
        ''}

    '' +
        (builtins.concatStringsSep "\n\n" (map (task: ''
            ${task.name}: ${ builtins.concatStringsSep " " (map (j: "${j.name}") task.depends) }
            ${
                if task.script == "" then "" else "\t"
            }${
                builtins.concatStringsSep "\n\t" (
                    builtins.filter (e: builtins.typeOf e != "list") (builtins.split "\n" task.script)
                )}
        '') task_list))
    );

    #: Generate a shell hook for tasks
    mkShellHook = tasks: /*bash*/ ''
        ${mkHelpScript tasks}
    '';

    #: Create a flake app that generates scripts, based on a task, in specified paths
    mkGenScriptsApp = task-files: {
        type = "app";
        program = let
            parts = lib.attrsets.mapAttrsToList (path: script: /*bash*/ ''
                echo "Generating ${path}..."

                # Create directory if it doesn't exist
                mkdir -p $(dirname ${path})

                # Copy script to destination
                cp -f ${script} ${path} || {
                    echo "Failed to generate ${path}."
                    exit 1
                }

            '') task-files;
            script = builtins.concatStringsSep "\n" parts;
        in
        toString (pkgs.writeShellScript "gen-scripts" /*bash*/ ''
            ${if builtins.length parts == 0 then "echo 'No scripts to generate.'; exit 0" else script}
            echo 'Done.'
        '');
    };

    # TODO: This assumes execution from the root of the project
    #: Generate a task to run the app which generates scripts in specified paths
    mkGenScriptsTask = name: mkTask "generate-scripts" { script = "nix run .#${name}"; };

}
